"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executeActor = executeActor;
exports.getBuildByTag = getBuildByTag;
exports.getDefaultBuild = getDefaultBuild;
exports.runActorApi = runActorApi;
const n8n_workflow_1 = require("n8n-workflow");
const genericFunctions_1 = require("./genericFunctions");
async function executeActor(params) {
    var _a;
    const { actorId, timeout, memory, buildParam, rawStringifiedInput, waitForFinish = false, } = params;
    let userInput;
    try {
        userInput = (0, genericFunctions_1.customBodyParser)(rawStringifiedInput);
    }
    catch (err) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), `Could not parse custom body: ${rawStringifiedInput}`);
    }
    if (!actorId) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Actor ID is required');
    }
    const actor = await genericFunctions_1.apiRequest.call(this, {
        method: 'GET',
        uri: `/v2/acts/${actorId}`,
    });
    if (!actor || !actor.data) {
        throw new n8n_workflow_1.NodeApiError(this.getNode(), {
            message: `Actor ${actorId} not found`,
        });
    }
    const actorData = actor.data;
    let build;
    if (buildParam) {
        build = await getBuildByTag.call(this, actorId, buildParam, actorData);
    }
    else {
        build = await getDefaultBuild.call(this, actorId);
    }
    const qs = {};
    if (timeout != null)
        qs.timeout = timeout;
    if (memory != null)
        qs.memory = memory;
    if (build === null || build === void 0 ? void 0 : build.buildNumber)
        qs.build = build.buildNumber;
    qs.waitForFinish = 0;
    const run = await runActorApi.call(this, actorId, userInput, qs);
    if (!((_a = run === null || run === void 0 ? void 0 : run.data) === null || _a === void 0 ? void 0 : _a.id)) {
        throw new n8n_workflow_1.NodeApiError(this.getNode(), {
            message: `Run ID not found after running the actor`,
        });
    }
    const runId = run.data.id;
    let lastRunData = run.data;
    if (waitForFinish) {
        lastRunData = await genericFunctions_1.pollRunStatus.call(this, runId);
    }
    return {
        runId,
        lastRunData,
    };
}
async function getBuildByTag(actorId, buildTag, actorData) {
    var _a, _b;
    const buildByTag = actorData.taggedBuilds && actorData.taggedBuilds[buildTag];
    if (!(buildByTag === null || buildByTag === void 0 ? void 0 : buildByTag.buildId)) {
        throw new n8n_workflow_1.NodeApiError(this.getNode(), {
            message: `Build tag '${buildTag}' does not exist for actor ${(_b = (_a = actorData.title) !== null && _a !== void 0 ? _a : actorData.name) !== null && _b !== void 0 ? _b : actorId}`,
        });
    }
    const buildResp = await genericFunctions_1.apiRequest.call(this, {
        method: 'GET',
        uri: `/v2/actor-builds/${buildByTag.buildId}`,
    });
    if (!buildResp || !buildResp.data) {
        throw new n8n_workflow_1.NodeApiError(this.getNode(), {
            message: `Build with ID '${buildByTag.buildId}' not found for actor ${actorId}`,
        });
    }
    return buildResp.data;
}
async function getDefaultBuild(actorId) {
    const defaultBuildResp = await genericFunctions_1.apiRequest.call(this, {
        method: 'GET',
        uri: `/v2/acts/${actorId}/builds/default`,
    });
    if (!defaultBuildResp || !defaultBuildResp.data) {
        throw new n8n_workflow_1.NodeApiError(this.getNode(), {
            message: `Could not fetch default build for actor ${actorId}`,
        });
    }
    return defaultBuildResp.data;
}
async function runActorApi(actorId, mergedInput, qs) {
    return await genericFunctions_1.apiRequest.call(this, {
        method: 'POST',
        uri: `/v2/acts/${actorId}/runs`,
        body: mergedInput,
        qs,
    });
}
//# sourceMappingURL=executeActor.js.map